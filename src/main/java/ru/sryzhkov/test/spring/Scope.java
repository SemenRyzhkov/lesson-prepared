package ru.sryzhkov.test.spring;


//Какой у Spring бинов скоуп по умолчанию?
//
//В Spring Framework во всех определениях бизнес-сущностей (bean) явно или неявно
// присутствует атрибут scope. В Java-конфигурации он передается в аннотации @Scope,
// в xml – в атрибуте scope тега <bean>.
//
//Атрибут scope – это строка-идентификатор, которая ставит бину в соответствие
// экземпляр класса org.springframework.beans.factory.config.Scope.
// Скоуп – реализация паттерна «стратегия» для фабрик бинов, инструкция по созданию бизнес-объектов.
//
//В простейшем Spring-приложении всегда существует два сокоупа:
//        • singleton – объект создается однажды, при последующих внедрениях переиспользуется.
//        Полезен для большинства случаев: различные сервисы, объекты без состояния, неизменяемые объекты.
//        Стоит заметить, это не класс-синглтон: при объявлении двух бинов одного класса их экземпляров будет два.
//        Это скоуп по умолчанию.
//        • prototype – при каждом внедрении фабрика бинов создает новый объект.
//        Нужен для изменяемых бинов с состоянием.
//
//Spring Web добавляет 4 дополнительных скоупа, которые делают бин синглтоном в пределах
// обработки одного сетевого запроса (request), клиентской сессии (session),
// контекста сервлета (application) и вебсокет-сессии (websocket).
//
//Разработчик может добавлять собственные скоупы. Пример реализации одного можно найти
// в самих исходниках Spring: SimpleThreadScope, который делает бин тред-локальным.
// Для использования его, как и пользовательские скоупы, нужно сначала зарегистрировать в BeanFactory.

//Как работает инъекция прототипа в синглтон?
//
//Раньше мы уже рассматривали (https://t.me/javatasks/1343) различия скоупов singleton и prototype в Spring Framework. Допустим ситуацию,
//// когда в singleton-компонент внедряется зависимость со скоупом prototype – когда будет создан её объект?
//
//Если просто добавить к определению бина аннотацию @Scope(SCOPE_PROTOTYPE), и использовать этот бин в синглтоне через аннотацию
//@Autowired – будет создан только один объект. Потому что синглтон создается только однажды, и обращение к прототипу случится тоже однажды при его создании
//при внедрении зависимости).
//
//Примитивный способ получать новый объект при каждом обращении – отказаться от @Autowired, и доставать его из контекста вручную. Для этого нужно вызывать
//context.getBean(MyPrototype.class).
//
//Воспользоваться автоматическим внедрением зависимостей можно через внедрение метода (паттерн «Команда»). Автовайрится не сам объект, а производящий его метод.
//
//Более красивый декларативный способ – правильно настроить определение бина. В аннотации @Scope кроме самого scopeName доступен второй параметр – proxyMode.
//По умолчанию его значение NO – прокси не создается. Но если указать INTERFACES или TARGET_CLASS, то под @Autowired будет внедряться не сам объект,
//а сгенерированный фреймворком прокси.
//И когда проксируемый бин имеет скоуп prototype, то объект внутри прокси будет пересоздаваться при каждом обращении.
public class Scope {
}
