### Способы обеспечения идемпотентности
1. Есть ticket - обращение пользователя в поддержку
2. Есть article - одно сообщение в рамках обращения

Нужно идемпотентно выполнять операцию addArticle(ticketId), 
чтобы в переписке не было дублей сообщений из-за сетевых проблем и т.п.

#### №1 

Через ключ идемпотентности + unique constraint

В запрос на добавление article добавляется параметр idempotency_key

В той же транзакции, где делаем insert into article, мы делаем insert в таблицу с ключами идемпотентности — 
у этой таблицы должен быть unique constraint

```sql
begin;

insert into idempotency_keys; //ошибка если уже существует

insert into article;

commit;
```

Атомарность — либо оба insert-а выполнятся, либо никакой
Ограничение unique constraint — insert в таблицу с ключами выполняется не более одного раза

Складывая эти факты, получаем что то что нужно: insert в таблицу article выполняется не более одного раза

Вариации:
1.1. Ключ идемпотентности может лежать не в отдельной таблице, а просто как колонка в article
1.2. Можно делать 
```sql
    insert on conflict do nothing;
```
чтобы обойтись без эксепшенов



#### №2

Через оптимистические блокировки

В запрос на добавление article добавляется параметр ticket_version

В той же транзакции, где делаем insert into article, мы проверяем что в бд лежит действительно та версия ticket, 
которую мы хотим обновить. Если это не так, то кидаем ошибку

```sql
begin

insert into article;

update ticket
set version = version + 1
where version = {version}
returning *; // из приложения кидаем ошибку, если не смогли произвести апдейт

commit;

```

Атомарность — либо и insert, и update версии выполнятся, либо не выполнится ничего
Обновление версии — если в бд лежит ticket с ticket_version = 1, то из двух параллельных запросов 
на обновление версии выполнится только один. Просто потому что бд гарантирует, что не будет аномалии lost update

И снова складывая эти факты, получаем требуемое